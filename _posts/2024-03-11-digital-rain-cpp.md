---
layout: post
title: C++ Matrix Digital Rain
tags: cpp coding project
categories: demo
---
##### Shannon Fernandes

## Introduction
We have all seen the digital rain from the Matrix seriesâ€”the iconic green falling Japanese and Roman characters, and Arabic numerals. Simon Whiteley created the Matrix code. In an interview with CNet, Simon said that the characters were scanned from his wife's Japanese cookbooks further saying "I like to tell everybody that the Matrix code is made of Japanese sushi recipes".It has since become the characteristic mark of the franchise, often used in other pop culture media to portray a hacker looking at 3 screens and saying "I'm in". 

Though I will not be hacking anything in this project, I will be creating my take on the digital rain in C++, implementing modern practices and delving deeper into some features provided by the standard C++ library.

Here is a table of features used from C++ 

| Feature| Purpose |
| -----------| ----------- |
| Vectors| Hold status of async tasks|
| Deques | Implement raindrop of characters|
| Async Function | Print multiple raindrops concurrently|
| Recursion | Raindrop printing logic|
| Mutexes   | Sharing access to cursor pointer|
| Random Device   | Seed random engine|
| Random Engine   | Generate pseudo random characters|
| Distribution   | Constrain random engine to required range|

## Algorithm

There are many ways I visualise the Matrix Digital rain. I first watched plenty of digital rains created by other people online, using coding languages or graphics tools. I slowed these videos down to see whether I could find any patterns in how the characters, rows, or columns moved and changed. 

My best friend when creating this algorithm was the mighty pen and paper. 
Drawing multiple states of a single raindrop helped me visualise how my algorithm would work, making patterns jump out to me. Noting the X and Y coordinates of a single raindrop's lifetime was how I picked out repeating logic that could be looped, and the relation between the size of the raindrop and its start and end points.

*Fig.1.1 INSERT IMAGE OF THE DRAWINGS HERE*

### Digital Drop Logic

Every droplet begins as a vector of a random number of random characters. It was easier for me to visualise the raindrop already existing, with a method to print it as opposed to printing the state of the raindrop, adding or not adding a character, and printing it again.

I used C++ random device and random engine since random devices are `non-deterministic`, using sources of entropy from hardware or the operating system. The number generated from the random device is used to seed the random engine. Random engines are `pseudo-random`, implementing algorithms, seeded with the value from a random device. The Mersenne Twister Engine is a widely used 32-bit random number generator that is my engine of choice for this project.

I create a uniform distribution to ensure the numbers generated by the random engine is within the range of ASCII values I want shown on screen. 

*Fig.1.2 Code used to generate random characters*

#### Rain Drop

Designing a raindrop to cascade down the screen is a priority for the visualisation of the overall rain. This will form a basis for the later expansion into the rain formation and rain disappearing visualisations.

*insert image of drawing here*

From the above image, you can see my thought process, looking at the states of the raindrop in terms of a `startPoint` (Y-axis value of the `tail of the droplet`), `endpoint`(Y-axis value of the `head of the droplet`) and `end of page` (where the droplet will `start disappearing`).

When creating code for this logic, I knew that I would like the droplet's print function to print the entire raindrop's status at one point in time. When given the start point of the droplet, the print function prints the raindrop bottom-up, starting with the head of the raindrop.  start point. 

*insert image of code here*

#### Rain Formation
*insert image of drawing here*

In the edge case of a rain droplet forming, the start point and end point are both initially at (0,0). The Y-axis value of the end point is incremented until all the characters fit on the screen.

*insert image of code here*


#### Rain Disappear
*insert image of drawing here*

The logic for the droplet disappearing was comparatively the simplest. When the head of the rain drop reaches the end of the page, dequeue the element on the front of the deque and print the droplet again with the new head of the rain drop at the end of the page.

*insert image of code here*

Printing a raindrop falling seemed repetitive, with the start point of the droplet increasing by 1 after the droplet had formed completely on the screen. I then created a recursive function that would take in an initial start point, print the droplet, increment the start point, and then call the print function again from the new

*talk about the recursive method of printing the droplet*


Each deque would be an instance of a DigitalDroplet and form a column.
A deque(short form for double-ended queue) is an indexed sequence container that allows insertion and deletion at both its beginning and end. This perfectly suited to my visualisation of every Droplet having a character enqueued from the back, but the top-most character dequeued when the droplet reaches its endpoint. While both the vector and deque are dynamically-sized data structures, the expansion of a deque is cheaper than that of a vector because it does not copy the existing elements to a new memory location. This comes at a cost of a larger initial memory since a deque holding just one element has to allocate its full internal array (8 times the object size).

### Digital Rain Logic
I came up with 2 ways of implementing the digital rain.
1. Creating a matrix using a 2D Vector:
Each column would represent a droplet on the screen. The droplet would fall vertically. Using a random hex code generator that gets converted to binary, with every binary digit corresponding to a column, if the corresponding binary digit was a 1, a random character generator would push a character to the end of that vector. If the binary digit was a 0, the droplet would continuously fall until the droplet disappeared. There were 2 reaons for me to now follow with this concept:
    - In a 2D array, every nested array is a row. Using the vector method push_back() would not work seamlessly with this concept that would require every nested vector to be a column.
    - Though I found the concept of using a Hex-to-Binary generator that would control the lifetime of every raindrop, this felt overcomplicated
    - This concept because I made another concept that was more intuitive and felt more realistically implementable.

2. Creating an async task for every deque
   This implementation diverges from the previous concept, using a vector of async tasks to handle the printing of each raindrop. 
It was more intuitive since I started drawing out a status diagram for the flow of a droplet in 3 main parts:
   - Rain Formation
   - Rain Fall
   - Rain disappear
   It was easier getting the code to work for a single droplet using the logic I prototyped, and later replicating the same logic for every column using async. I was also able to get the code working using threads, but decided to go with async because that is what I started with *NEED A BETTER REASON TO JUSTIFY THIS*.



## Problem-Solving
### Handling Multiple RainDrops
Once I was able to get the logic of a single raindrop working from formation to disappearing, the next step was to figure out how I would replicate this behaviour for multiple columns. 

The first step was to use a for loop, but this led to a laggy effect since only one raindrop would be updated at a time, leaving the other raindrops frozen in place.

Due to my investigation into JavaScript's asynchronous features, I was inclined to look into concurrency in C++ and whether there was another way to approach this issue. It was intuitive to have a single thread responsible for printing a single droplet. 

*insert code using thread*

*insert code using asyncs*

When a Droplet finishes printing 
*insert drawing of status array used to control status of tasks*

#### Sharing Access to the Console Cursor
Getting multiple raindrops printed introduced quirky behaviour with the cursor getting *lost*. 

*insert image of cursor being lost*

A mutex is a synchronisation object that is used to control access to a shared resource in a concurrent or multithreaded program. To synchronise access to the cursor which is our shared resource in this case, a mutex is created as a static variable in the DigitalRain class, ensuring the same mutex is shared between all instances of DigitalRain and by extension, all DigitalDroplets. The mutex is passed by reference to the print function, where the mutex is locked right before the console is accessed. The mutex is automatically unlocked after it code escapes the scope of the mutex being locked.

*insert code of mutex in DigitalRain*


You can add an image that has been uploaded to the repository in a /docs/assets/images folder.

<img src="https://raw.githubusercontent.com/shannon3335/recursive-digital-rain-cpp/main/docs/assets/154-23-5-27-18-45-6m.jpg" width="100" height="100">
