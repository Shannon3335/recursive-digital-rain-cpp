---
layout: post
title: C++ Matrix Digital Rain
tags: cpp coding project
categories: demo
---
##### Shannon Fernandes

## Introduction
We have all seen the digital rain from the Matrix seriesâ€”the iconic green falling Japanese and Roman characters, and Arabic numerals. Simon Whiteley created the Matrix code. In an interview with CNet, Simon said that the characters were scanned from his wife's Japanese cookbooks further saying "I like to tell everybody that the Matrix code is made of Japanese sushi recipes".It has since become the characteristic mark of the franchise, often used in other pop culture media to portray a hacker looking at 3 screens and saying "I'm in". 

Though I will not be hacking anything in this project, I will showcase my take on digital rain in C++, implementing modern practices and delving deeper into some features in the standard C++ library.

Here is a table of features used from C++ 

| Feature| Purpose |
| -----------| ----------- |
| Vectors| Hold status of async tasks|
| Deques | Implement raindrop of characters|
| Async Function | Print multiple raindrops concurrently|
| Recursion | Raindrop printing logic|
| Mutexes   | Sharing access to cursor pointer|
| Random Device   | Seed random engine|
| Random Engine   | Generate pseudo-random characters|
| Distribution   | Constrain random engine to required range|

## Algorithm

There are many ways I visualise the Matrix Digital rain. I first watched plenty of digital rains created by other people online, using coding languages or graphics tools. I slowed these videos down to see whether I could find any patterns in how the characters, rows, or columns moved and changed. 

My best friend when creating this algorithm was the mighty pen and paper. 
Drawing multiple states of a single raindrop helped me visualise how my algorithm would work, making patterns jump out to me. Noting the X and Y coordinates of a single raindrop's lifetime was how I picked out repeating logic that could be looped, and the relation between the size of the raindrop and its start and end points.

*Fig.1.1 INSERT IMAGE OF THE DRAWINGS HERE*

### Digital Droplet Logic

Every droplet begins as a `deque of a random number of random characters` representing a column. It was easier for me to visualise an existing raindrop with a method to print it as opposed to printing the state of a raindrop, conditionally adding a character, and printing it again.

Each deque would be an instance of a DigitalDroplet and form a column. A deque(short form for double-ended queue) is an indexed sequence container that allows insertion and deletion at both its beginning and end. This perfectly suited to my visualisation of every Droplet having a character enqueued from the back, but the top-most character dequeued when the droplet reaches the end of page. While both vectors and deques are dynamically sized data structures, the expansion of a deque is cheaper than that of a vector because it does not copy the existing elements to a new memory location. This comes at the cost of a larger initial memory since a deque holding just one element has to allocate its full internal array (8 times the object size).

I used C++'s random device and random engine since random devices are `non-deterministic`, using sources of entropy from hardware or the operating system. The number generated from the random device is used to seed the random engine. Random engines are `pseudo-random`, implementing algorithms, seeded with the value from a random device. The Mersenne Twister Engine is a widely used 32-bit random number generator that is my engine of choice for this project.

I create a uniform distribution to ensure the numbers generated by the random engine is within the range of ASCII values I want shown on screen. 

*Fig.1.2 Code used to generate random characters*

1. #### Rain Drop

Designing a raindrop to cascade down the screen is a priority for the visualisation of the overall rain. This will form a basis for the later expansion into the rain formation and rain disappearing visualisations.
*Fig.1.3 INSERT IMAGE OF SAMPLE RAIN DROP PROCESS*
From the above image, you can see my thought process, looking at the states of the raindrop in terms of a `startPoint` (Y-axis value of the `tail of the droplet`), `endpoint`(Y-axis value of the `head of the droplet`) and `end of page` (where the droplet will `start disappearing`).

When creating code for this logic, I knew that I would like the droplet's print function to print the entire raindrop's status at one point in time. When given the start point of the droplet, the print function prints the raindrop bottom-up, starting with the head of the raindrop.  

*Fig.1.4 INSERT IMAGE OF RAIN DROP CODE*

2. #### Rain Formation

*Fig.1.5 INSERT IMAGE OF SAMPLE RAIN FORMATION PROCESS*

Rain Formation is the name I gave the case where the droplet starts with only the first character on screen.
Since the droplet already exists with a random number of characters, I use a for loop to print the head of the droplet first, going down the Y axis every iteration, revealing another character until all characters are on screen with the tail of the droplet still at (X,0). 

*Fig.1.6 INSERT IMAGE OF RAIN FORMATION CODE*


3. #### Rain Disappear

*Fig.1.7 INSERT IMAGE OF RAIN DISAPPEARING EXAMPLE*

The logic for the droplet disappearing was comparatively the simplest. When the head of the raindrop reaches the end of the page, dequeue the current head of the droplet and print it again with the new head of the rain drop at the end of the page.

*Fig.1.8 INSERT IMAGE OF RAIN DISAPPEARING CODE*


4. #### Recursion


*Fig.1.8 RECURSION FUNCTION LOGIC*

Noticing a repetition in printing a raindrop, I create a recursive function that would take in an initial start point, print the droplet, increment the start point, and call the print function again with a new start point. I could have used a nested for loop to repeat this logic, but opted to use recursive logic since the deque being empty was a clear end case and it was easier to understand the logic in the recursive method.



### Digital Rain Logic

My logic to handle multiple droplets is an extension of my raindrop logic, having code that handles every raindrop independently. Using  for loop to print each droplet sequentially resulted in a predictable pattern because the recursive function's self-calling nature caused each droplet to block other print function its lifespan before the next iteration of the loop could occur.

Surrounded by concurrency in GoLang and JavaScript, I devised a solution using an array to track the statuses of asynchronous tasks printing raindrops. I have created a proof of concept using both asynchronous tasks and threads but decided to go with asynchronous tasks. Using async tasks in C++ gives an abstracted way to to handle concurrency `without managing promises, responses, threadpools`, while giving an `easier way to return values` from the tasks compared to threads. Threads, however, provide granular control over performance, with the possibility of `true parallelism`, with the tradeoff being higher resource utilisation.

*Fig.3.1 DRAWING OF STATUS ARRAY USED TO CONTROL STATUS OF TASKS*

Each asynchronous task in the array is associated with a raindrop. When a task was initiated, its corresponding index in the status array was set to 1. Upon completion of the recursive function, signified by the return value meeting the end condition, the status value for that index was reset to 0.

*Fig.3.2 ASYNC CODE USING STATUS ARRAYS*

## Problem-Solving

1. ### Handling Multiple RainDrops

Once I got the logic of a single raindrop working from formation to disappearing, the next step was to figure out how I would replicate this behaviour for multiple columns. 

Initially, I attempted to use a for loop to update the raindrops, but this approach caused a laggy effect because only one raindrop was updated at a time, leaving the others frozen. To address this, I experimented with methods keeping concurrency as the last solution, such as adjusting sleep times between print operations and increasing the sleep time between recursive calls. However, I realized that this approach wouldn't work due to the nested nature of recursive functions. The recursive function formed a nested priority stack following a Last-In-First-Out (LIFO) order, which monopolized priority and prevented it from passing to other raindrops.

In the end, I fixed the problem by using async tasks to handle the printing of each raindrop. I also tackled the issue of the shared console by using a mutex, which helped coordinate the output of each raindrop.

2.#### Sharing Access to the Console Cursor
Getting multiple raindrops printed introduced quirky behaviour with the cursor getting *lost*. 

*Fig.4.1 INSERT IMAGE OF CURSOR GETTING LOST*

A mutex is a synchronisation object that is used to control access to a shared resource in a concurrent or multithreaded program. To synchronise access to the cursor which is our shared resource in this case, a mutex is created as a static variable in the DigitalRain class, ensuring the same mutex is shared between all instances of DigitalRain and by extension, all DigitalDroplets. The mutex is passed by reference to the print function, where the mutex is locked right before the console is accessed. The mutex is automatically unlocked after it code escapes the scope of the mutex being locked.

*Fig.4.2 INSERT CODE USING MUTEX*


You can add an image that has been uploaded to the repository in a /docs/assets/images folder.

<img src="https://raw.githubusercontent.com/shannon3335/recursive-digital-rain-cpp/main/docs/assets/154-23-5-27-18-45-6m.jpg" width="100" height="100">
